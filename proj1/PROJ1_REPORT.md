# Project 1 Experience Report 

As we explored five interesting projects given to us, our goal was to find the one that we would like to work on in Project 2. After looking at each project closely and using different criteria, we chose the one that intrigued us the most. Our chosen project is about sentiment analysis, a field in computer science that uses a computer chip but understands complex human sentiments. Using this we would like to predict how users feel with as most accuracy, and we have four methods to do that: Document Analysis, Text Analysis, Product Analysis, and Audio Analysis. Even though this project is just getting started, it has a lot of potential and could be helpful in many different areas of society. When we evaluated the projects, we carefully looked at the documentation, checked how much of the code was covered, tested the API, and thought about how practical each project was. This journey not only led us to a promising project but also gave us a deeper understanding of sentiment analysis and its potential in the future. The rubrics critiqued the project from different aspects of usability and scalability, as well as ease of working and understanding.

Our journey didn't end with selecting the project; it continued into the realm of implementation. To work on this project, you'll need some technologies like Python3, Django, HTML, CSS, Scrappy, and the Vader Analysis Tool. To bring our vision to life, we followed a systematic process. First, we ensured that all the required dependencies were installed. A crucial step was to make the necessary path changes in specific files, which we meticulously documented in our issue tracker. With the groundwork laid, we initiated the Django server. This action paved the way for accessing the project's web user interface (web UI) through a web browser. Opening your browser and entering localhost:8000 in the search bar unveiled the webUI of our application. Here, users are presented with various input options, including URL, file, or regular text input, allowing for a versatile and user-friendly experience. This thoughtful design enhances the accessibility and usability of our sentiment analysis project.

Implementing this project from GitHub involved a number of unforeseen issues that required technical expertise to resolve. The main issue was that the project's requirements file was deficient in important packages like speech_recognition, vaderSentiment, and pdfminer. The manual installation of these dependencies was required to fix the runtime faults caused by this flaw, which raised the possibility of inconsistent behavior and increased complexity in the development environment. Additionally, we ran into problems related to outdated/deprecated Python packages when attempting to synchronize the project's dependencies using the 'pip install -r requirements.txt' command. We had to diligently locate and install the most recent versions of these packages in order to overcome this. Alternative packages had to be found and included in the project when installation difficulties were brought on by problems with metadata retrieval. We also faced an "OSError'' while running the project as some of the modules needed admin privileges to be executed, which made things even more complex. This revealed a larger issue about security and access controls during the project's deployment and the requirement for a strong permission management system. The existence of hard-coded absolute file paths throughout the project was one really technical problem. The absolute paths corresponded to the directory structure of the developer who coded the project without taking into account that whosoever will be cloning this project in the future will not have the same directory structure in the majority of the cases. We had to go and change each such path scattered throughout the project to make it successfully run. Last but not least, a frustrating problem arose when a post request unintentionally targeted the wrong server and resulted in a "Path not found" error. This brought to light a basic problem with network configuration or server settings.

To tackle the challenges faced during the implementation of Project 1 and prevent similar issues in the future, the following are the practices we will be committing to perform in Project 2:

1. Staying Up-to-Date with Dependencies: It's like keeping your toolbox organized. Regularly check and update the project's requirements list. This list is like your shopping list for tools, so make sure it includes all the right dependencies with their version numbers.
2. Create Virtual Environments: Think of virtual environments as project bubbles. They keep each project separate, so the tools for one project don't get mixed up with another. It's like having different workspaces for different tasks and keeping things neat and tidy.
3. Dependency Management: Tools like `pipenv` or `conda`can be used. They keep track of your dependencies, making sure you have the right versions and helping you manage them effortlessly.
4. Specify Versions Clearly: When you list tools in your requirements, be specific, like ordering a particular brand and model. It ensures compatibility and reduces surprises. Just like how you might ask for a specific smartphone model when shopping.
5. Control Access and Permissions:  Imagine if your project was a secure vault. You'd want to clearly document who can access it and how. Make sure your project's users and settings are well-documented, and keep your project's space isolated from the rest of the system.
6. Dynamic File Paths:  Instead of writing down fixed addresses like writing a note on a map, use dynamic paths. Think of them like GPS coordinates; they adapt to different systems. This way, your project can find its way on any computer.
7. Regular Maintenance and Testing:  Just like you'd take care of your garden by watering and pruning regularly, your project needs attention too. Set aside time for testing, maintenance, and updates. This keeps everything fresh and working smoothly, ready for whatever comes its way.


